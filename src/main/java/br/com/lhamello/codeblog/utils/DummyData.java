package br.com.lhamello.codeblog.utils;

import java.time.LocalDate;
import java.util.LinkedList;
import java.util.List;

import org.springframework.stereotype.Component;

import br.com.lhamello.codeblog.model.Post;
import br.com.lhamello.codeblog.repository.PostRepository;

@Component
public class DummyData {

  private final PostRepository postRepository;

  public DummyData(final PostRepository postRepository) {
    this.postRepository = postRepository;
  }

//  @PostConstruct
  public void savePosts() {
    List<Post> posts = new LinkedList<>();

    posts.add(this.createPost1());
    posts.add(this.createPost2());
    posts.add(this.createPost3());
    posts.add(this.createPost4());

    for (Post post : posts) {
      Post postSaved = postRepository.save(post);
      System.out.println(postSaved.getId());
    }
  }

  private Post newPost(final String autor, final String titulo, final String texto) {
    Post post = new Post();
    post.setAutor(autor);
    post.setData(LocalDate.now());
    post.setTitulo(titulo);
    post.setTexto(texto);
    return post;
  }

  private Post createPost1() {
    return newPost("Luiz Mello", "Docker",
        "Docker é um software contêiner da empresa Docker, Inc, que fornece uma camada de abstração e automação para virtualização de sistema operacional no Windows e no Linux,[1][2] usando isolamento de recurso do núcleo do Linux como cgroups e espaços de nomes do núcleo, e um sistema de arquivos com recursos de união, como OverlayFS[3] criando contêineres independentes para executar dentro de uma única instância do sistema operacional, evitando a sobrecarga de manter máquinas virtuais (VM).[4]\r\n"
            + "\r\n"
            + "O suporte para espaços de nomes do núcleo do Linux na maioria das vezes[5] isola uma visão da aplicação do ambiente operacional, incluindo árvores de processo, rede, IDs de usuário e sistemas de arquivos montados, uma vez que os cgroups do núcleo fornecem limitação de recursos, incluindo a UCP, memória, bloco de E/S e rede. Desde a versão 0.9, o Docker inclui a biblioteca libcontainer como seu próprio mecanismo de usar diretamente os recursos de virtualização fornecidos pelo núcleo do Linux, além de usar interfaces de virtualização abstrata via libvirt, LXC (Linux Containers) e systemd-nspawn.[6][7][8]. Visão geral\r\n"
            + "O docker é uma alternativa de virtualização em que o kernel da máquina hospedeira é compartilhado com a máquina virtualizada ou o software em operação, portanto um desenvolvedor pode agregar a seu software a possibilidade de levar as bibliotecas e outras dependências do seu programa junto ao software com menos perda de desempenho do que a virtualização do hardware de um servidor completo. Assim, o docker torna operações em uma infraestrutura como serviços web mais intercambiável, eficientes e flexíveis.\r\n"
            + "\r\n"
            + "Segundo uma análise da 451 Research, o \"docker é uma ferramenta que pode empacotar um aplicativo e suas dependências em um recipiente virtual que pode ser executado em qualquer servidor Linux. Isso ajuda a permitir flexibilidade e portabilidade de onde o aplicativo pode ser executado, quer nas instalações, nuvem pública, nuvem privada, entre outros.\"[9]");
  }

  private Post createPost2() {
    return newPost("Luiz Melo", "API Rest",
        "Representational State Transfer (REST), em português Transferência Representacional de Estado, é um estilo de arquitetura de software que define um conjunto de restrições a serem usadas para a criação de web services (serviços Web). Os Web services que estão em conformidade com o estilo arquitetural REST, denominados Web services RESTful, fornecem interoperabilidade entre sistemas de computadores na Internet. Os Web services RESTful permitem que os sistemas solicitantes acessem e manipulem representações textuais de recursos da Web usando um conjunto uniforme e predefinido de operações sem estado. Outros tipos de Web services, como Web services SOAP, expõem seus próprios conjuntos de operações arbitrários.[1][1]\r\n"
            + "\r\n"
            + "\"Recursos da Web\" foram definidos pela primeira vez na World Wide Web como documentos ou arquivos identificados por suas URLs. No entanto, hoje, eles têm uma definição muito mais genérica e abstrata que engloba qualquer coisa ou entidade que pode ser identificada, nomeada, endereçada ou manipulada, da forma que for, na Web. Em um Web service RESTful, as solicitações feitas ao URI de um recurso provocará uma resposta com uma carga útil formatada em HTML, XML, JSON ou algum outro formato. A resposta pode confirmar que alguma alteração foi feita no recurso armazenado e a resposta pode fornecer links de hipertexto para outros recursos ou conjuntos de recursos relacionados. Quando o HTTP é usado, como é o mais comum, as operações (métodos HTTP) disponíveis são GET, HEAD, POST, PUT, PATCH, DELETE, CONNECT, OPTIONS e TRACE.[2]\r\n"
            + "\r\n"
            + "Usando um protocolo sem estado e operações padrão, os sistemas RESTful buscam desempenho, confiabilidade e capacidade de crescimento rápido, reutilizando componentes que podem ser gerenciados e atualizados sem afetar o sistema como um todo, mesmo enquanto estiver em execução.\r\n"
            + "\r\n"
            + "O termo transferência de estado representacional foi introduzido e definido em 2000 por Roy Fielding em sua tese de doutoramento.[3][4] A dissertação de Fielding explicou os princípios REST que eram conhecidos como \"modelo de objeto HTTP\", a partir de 1994, e foram usados ​​no projeto dos padrões HTTP 1.1 e URI (Uniform Resource Identifiers).[5][6] O termo destina-se a evocar uma imagem de como um aplicativo da Web bem projetado se comporta: é uma rede de recursos da Web (uma máquina de estados virtuais) na qual o usuário avança pelo aplicativo selecionando identificadores de recursos, como http://www.exemplo.com/artigos/21, e operações de recursos, como GET ou POST (transições de estado do aplicativo), resultando na próxima representação do recurso (o próximo estado do aplicativo) sendo transferida para o usuário final para seu uso.");
  }

  private Post createPost3() {
    return newPost("Luiz Mello", "Git",
        "Git pronuncia-se /git/ (ou pronuncia-se /djit/ em inglês britânico) é um sistema de controle de versões distribuído, usado principalmente no desenvolvimento de software, mas pode ser usado para registrar o histórico de edições de qualquer tipo de arquivo. O Git foi inicialmente projetado e desenvolvido por Linus Torvalds para o desenvolvimento do kernel Linux, mas foi adotado por muitos outros projetos.\r\n"
            + "\r\n"
            + "Cada diretório de trabalho do Git é um repositório com um histórico completo e habilidade total de acompanhamento das revisões, não dependente de acesso a uma rede ou a um servidor central. O Git também facilita a reprodutibilidade científica em uma ampla gama de disciplinas, da ecologia à bioinformática, arqueologia à zoologia.[1]\r\n"
            + "\r\n"
            + "O Git é um software livre, distribuído sob os termos da versão 2 da GNU General Public License. Sua manutenção é atualmente supervisionada por Junio Hamano. Nome\r\n"
            + "Quando perguntado sobre o porquê do nome, Linus Torvalds satirizou sobre o termo \"Git\", uma gíria em inglês britânico para cabeça dura, pessoas que acham que sempre têm razão, argumentativas, podendo ser também pessoa desagradável ou estúpida: [2][3][4]\r\n"
            + "\r\n" + "Eu sou um desgraçado egocêntrico, então batizo todos os meus projetos com meu nome. Primeiro Linux, agora Git.\r\n"
            + "Original (em inglês): I'm an egotistical bastard, so I name all my projects after myself. First Linux, now git.\r\n" + "— Linus Torvalds (em inglês)\r\n"
            + "Isto é especialmente irônico, pois o próprio Linus resistiu à ideia de escolher o nome Linux para o núcleo do sistema operacional criado por ele, por ser \"too complacent\" (\"muito arrogante\", em tradução livre).[5]\r\n"
            + "\r\n"
            + "Na wiki oficial, há explicações alternativas do próprio Torvald, explicando que git pode significar qualquer coisa, depende de seu humor. Podendo ser, meramente uma combinação de três letras pronunciáveis e não utilizadas atualmente por nenhum comando comum do UNIX; o retro acrônimo de Global information tracker, em português, Rastreamento global de informações; Ou, quando ele trava, \"Goddamn idiotic truckload of sh*t\"[3] História Inicial do git\r\n"
            + "O desenvolvimento do Git surgiu após vários desenvolvedores do kernel (núcleo) do Linux decidirem desistir de acessar ao sistema do BitKeeper, que é um software proprietário.[6] O acesso gratuito ao BitKeeper foi removido pelo detentor dos direitos autorais, Larry McVoy, depois de acusar Andrew Tridgell de usar de engenharia reversa nos protocolos do BitKeeper, alegando violação da licença do mesmo. Tridgell demonstrou, em uma apresentação na Linux.Conf.Au, realizada em 2005, que o processo de engenharia reversa utilizado não foi mais do que simplesmente direcionar um telnet para a porta apropriada de um servidor BitKeeper e digitar \"help (ajuda)\".[7]\r\n"
            + "\r\n"
            + "Torvalds queria um sistema distribuído que ele pudesse utilizar de forma similar ao BitKeeper (BK), mas nenhum dos sistemas gratuitos disponíveis atendia suas necessidades, particularmente com relação à performance. Segue abaixo uma parte retirada de um e-mail, de 7 de Abril de 2005, escrito enquanto desenvolvia seu primeiro protótipo:[8]\r\n"
            + "\r\n"
            + "De qualquer forma, os SCVs que olhei dificultam as coisas. Uma delas (a maior delas, na verdade) que estive trabalhando é fazer este processo ser realmente eficiente. Se leva meio minuto para aplicar um patch e ainda lembrar o que mudou, etc (e francamente, isso é rápido para a maioria dos SCVs por aí para um projeto do tamanho do Linux), daí uma série de 250 e-mails (que não é estranho acontecer quando eu sincronizo com o Andrew, por exemplo) demora duas horas. Se um dos patches no meio do processo não é aplicado, as coisas ficam realmente muito feias.\r\n"
            + "\r\n"
            + "Agora, o BK (BitKeeper) não era um inferno também (na verdade, comparado com todo o resto, o BK é um inferno em velocidade, geralmente em uma ou duas ordens de magnitude), e levou cerca de 10-15 segundos por e-mail quando mesclei meus arquivos com o Andrew. MESMO ASSIM, com o BK isso não era um problema tão grande, visto que mesclas de arquivos de BK←>BK eram tão fáceis, eu nunca precisei das lentas mesclas por e-mail com nenhum dos outros desenvolvedores principais. Então um \"mesclador\" de um SCV baseado em patches precisaria ser realmente mais rápido que o BK. O que realmente é extremamente difícil.\r\n"
            + "\r\n"
            + "Então eu estou escrevendo alguns scripts para tentar alinhar tudo mais rápido. Indicações iniciais são de que eu poderei fazer isso tão rápido quanto eu aplico patches, mas para ser franco, estou no máximo com metade pronto, e se eu estiver na direção errada, talvez essa não seja a mais pura verdade. De qualquer forma, a razão de que eu consigo criar tudo isso tão rápido é que meus scripts não serão um SCV, serão tipo um \"registro de estado do Linus\" bem específico. Isso vai fazer minhas mesclas lineares de patches muito mais eficientes no tempo, e nestas condições, possível.\r\n"
            + "\r\n"
            + "(Se a aplicação de um patch demora três segundos, até mesmo uma série grande de patches não é um problema: se eu for notificado em um minuto ou dois que falhou na metade do caminho, sem problemas, eu posso então simplesmente arrumar manualmente. É por isso que a latência é crítica - se eu tivesse que fazer as coisas efetivamente \"desconectado\", eu não poderia, por definição, arrumar as coisas quando problemas aparecessem).\r\n"
            + "Torvalds teve vários critérios para o projeto:\r\n" + "\r\n"
            + "Tomar o CVS como um exemplo do que não fazer; na dúvida, tomar exatamente a decisão contrária. Para citar Torvalds, de certa forma mordendo a língua:\r\n"
            + "\"Nos primeiros 10 anos de manutenção do kernel, nós literalmente usamos patches de tarballs, o que é muito superior como controle de versão que o CVS, mas eu acabei usando o CVS por 7 anos em uma empresa comercial [Transmeta[9]] e eu odiava de paixão. Quando eu digo que eu odiava de paixão, eu também tenho que dizer que, se houver algum usuário de SVN (Subversion) na platéia, talvez você queira sair. Porque meu ódio pelo CVS significa que eu vejo o Subversion como sendo o projeto iniciado mais sem objetivo de todos os tempos. O slogan do Subversion por um tempo foi \"CVS feito [do jeito] certo\", ou algo assim, e se você começa com esse slogan, você não vai a lugar nenhum. Não tem como o CVS fazer [do jeito] certo.\"\r\n"
            + "Suportar um fluxo distribuído, como o BitKeeper\r\n"
            + "\"O BitKeeper não foi simplesmente o primeiro sistema de versionamento que eu senti que absolutamente valia a pena, foi também o sistema de controle de versão que me ensinou porque eles têm um objetivo, e como você realmente deve fazer as coisas. Então o Git, de várias formas, mesmo que de uma visão técnica muito diferente do BitKeeper (e isso foi outro objetivo de projeto, porque eu queria deixar claro que não era um plágio do BitKeeper), muitos dos fluxos que usamos no Git vieram diretamente dos fluxos que aprendemos com o BitKeeper.\"\r\n"
            + "Várias firmes proteções contra corrompimento de arquivos, seja por acidente ou origem maldosa[10]\r\n" + "Alto desempenho\r\n"
            + "Os primeiros três critérios acima eliminam cada controle de versão preexistente ao Git, exceto pelo Monotone, e o quarto elimina todos. Então, imediatamente depois de liberar a versão 2.6.12-rc2 de desenvolvimento do kernel do Linux, ele começou a desenvolver o seu próprio.\r\n"
            + "\r\n"
            + "O desenvolvimento do Git começou em 3 de Abril de 2005.[11] O projeto foi anunciado em 6 de Abril,[12] e tornou-se autohospedeiro no dia 7 de Abril.[11] A primeira mescla de arquivos (merge) em múltiplos ramos (branches) foi realizado em 18 de Abril.[13] Torvalds alcançou seus objetivos de performance; em 29 de Abril, o recém-nascido Git se tornou referência ao registrar patches para a árvore de desenvolvimento do kernel do Linux na taxa de 6,7 por segundo.[14] No dia 16 de Junho, a entrega do kernel 2.6.12 foi gerenciada pelo Git.[15]\r\n"
            + "\r\n"
            + "Mesmo que fortemente influenciado pelo BitKeeper, Torvalds deliberadamente tentou evitar abordagens tradicionais, levando a um design único.[16] Ele desenvolveu o sistema até que fosse possível sua utilização por usuários técnicos, entregando então a manutenção do software para Junio Hamano, um dos principais colaboradores do projeto, em 16 de Julho de 2005.[17] Hamano foi responsável pela entrega da versão 1.0 em 21 de dezembro de 2005,[18] e continua como responsável pela manutenção do mesmo. Desenho\r\n"
            + "O desenho do Git foi inspirado no BitKeeper e no Monotone.[19][20] Seu desenho original era de um controle de versão de baixo nível, de forma que outros pudessem desenvolver interfaces em cima dele, como por exemplo o cogito ou o StGIT.[20] No entanto, o núcleo do projeto do Git se tornou, desde então, um sistema de controle de versão completo que pode ser diretamente utilizado.[21]\r\n"
            + "\r\n" + "Características\r\n"
            + "O projeto do Git é uma síntese da experiência de Torvalds com a manutenção do desenvolvimento altamente distribuído do projeto do Linux, junto com seu íntimo conhecimento de performance de sistemas de arquivos (conhecimentos adquiridos no mesmo projeto) e a necessidade urgente de produzir um sistema funcional em um curto espaço de tempo. Essas influências o levaram às seguintes escolhas de implementação:\r\n"
            + "\r\n" + "Suporte consistente para desenvolvimentos não lineares\r\n"
            + "O Git suporta rápidas criações de ramos (branches) e mesclas (merges), e inclui ferramentas específicas para visualização e navegação de históricos de desenvolvimento não lineares. Uma suposição intrínseca no Git é que uma mudança será mesclada mais do que é escrita, enquanto é passada por vários revisores.\r\n"
            + "Desenvolvimento distribuído\r\n"
            + "Assim como o Darcs, o BitKeeper, o Mercurial, o SVK, o Bazaar e o Monotone, o Git dá a cada desenvolvedor uma cópia local completa de todo o histórico de desenvolvimento, e as mudanças são copiadas de um único repositório para outro. Estas mudanças são importadas como ramos (branches) adicionais de desenvolvimento, e podem sofrer uma mescla (merge) da mesma forma que um ramo de desenvolvimento local.\r\n"
            + "Compatibilidade com protocolos/sistemas existentes\r\n"
            + "Repositórios podem ser publicados por HTTP, FTP, rsync, um protocolo Git sobre uma porta conhecida ou por ssh. O Git também tem uma emulação de servidor CVS, o que habilita a existência de clientes CVS e extensões (plugins) em diversos ADIs a utilizar os repositórios Git. O Subversion e o svk podem utilizar os repositórios diretamente com o git-svn.\r\n"
            + "Manipulação eficiente de projetos extensos\r\n"
            + "Torvalds descreveu o Git como sendo veloz e escalável,[22] e testes de performance realizados pela Mozilla apontaram que o Git é uma ordem de magnitude mais rápido que alguns sistemas de controle de versão. Obter o histórico das revisões salvos em repositórios locais resulta ser duas ordens de magnitude mais rápido que obtê-los de um servidor remoto.[23][24] Um detalhe interessante é que o Git não fica mais lento com o aumento do histórico do projeto.[25]\r\n"
            + "Autenticação criptográfica do histórico\r\n"
            + "O histórico do Git é salvo de uma maneira que o nome de uma determinada revisão (um \"commit\", ou entrega, nos termos do Git) depende de todo o histórico de desenvolvimento que leva até este commit. Uma vez publicado, não é possível mudar as versões antigas sem passar despercebido. A estrutura é similar a uma árvore hash (hash tree), mas com dados adicionais nos nós e nas folhas.[26] (o Mercurial e o Monotone também possuem esta propriedade.)\r\n"
            + "Modelo baseado em ferramentas\r\n"
            + "O Git foi modelado como um conjunto de programas escrito em C, e numerosos scripts em shell que encapsulam estes programas.[27] Embora muitos destes scripts tenham sido reescritos em C, como parte de um esforço de portar o Git para o Windows, o modelo básico continua, sendo fácil agrupar seus componentes.[28]\r\n"
            + "Estratégias de mescla (merge) conectáveis\r\n"
            + "Como parte de desenho em ferramentas, o Git tem um conjunto bem definido de modelos de uma mescla incompleta, e possuí vários algoritimos para completá-las, culminando em comunicar ao usuário que é incapaz de completar o merge automaticamente, sendo necessária uma edição manual.\r\n"
            + "O lixo se acumula se não for limpo\r\n"
            + "Abortar operações ou desfazer mudanças irá deixar objetos sem valor pendentes no banco de dados. Existe porém uma pequena fração desejável de objetos no sempre crescente histórico, mas liberar o espaço usando git gc --prune pode ser uma operação lenta.[29]\r\n"
            + "Empacotamento periódico explícito de objetos\r\n"
            + "O Git armazena cada novo objeto criado como um arquivo separado. Embora cada arquivo seja individualmente comprimido, isso requer um espaço considerável no disco e é ineficiente. Isto é resolvido com o uso de \"pacotes\" que armazenam um grande número de objetos em um único arquivo (ou pela rede), comprimidos pelo delta entre eles. Pacotes são comprimidos usando a heurística de que arquivos com o mesmo nome são provavelmente similares, mas que não dependam exatamente disso. Mesmo assim, novos objetos criados (novo histórico adicionado) são gravados um a um, e reempacotamentos periódicos são necessários para manter o espaço de forma eficiente. O Git faz reempacotamentos periódicos automaticamente, mas também é possível fazer reempacotamentos manuais com o comando git gc.\r\n"
            + "Outra propriedade do Git é que ele salva o estado (snapshot) dos diretórios de arquivos. Os sistemas mais antigos de controle de versão de código fonte, Sistemas de Controle de Código Fonte (SCCF) e Sistemas de Controle de Revisão (SCR), trabalhavam em cima de arquivos individuais, enfatizando o espaço em disco ganho por intercalação de deltas (SCCF) ou por codificação de deltas (RCS) entre versões (mais similares). Sistemas de controle de versão posteriores mantiveram esta noção de arquivos possuírem uma identidade através de múltiplas revisões de um projeto. Porém, Torvalds rejeitou esse conceito.[30] Consequentemente, o Git não salva relacionamentos entre revisão de arquivos em nenhum nível abaixo da árvore de diretório do código fonte.\r\n"
            + "\r\n" + "Relacionamentos inexplícitos de revisão remete a consequências significativas:\r\n" + "\r\n"
            + "É pouco mais dispendioso examinar o histórico de um único arquivo do que o histórico de todo o projeto.[31] Para obter o histórico de mudanças de um arquivo, Git precisa caminhar pelo histórico global e então verificar qual mudança modificou aquele arquivo. Este método de examinar o histórico faz, porém, com que o Git produza igual eficiência em mostrar um histórico de mudanças de um ou de vários arquivos arbitrários. Por exemplo, é comum o caso de um subdiretório da árvore de arquivos fontes mais um arquivo global de cabeçalho associado.\r\n"
            + "Renomeação de arquivos são feitos de forma implícita. Uma queixa comum no CVS é que este usa o nome do arquivo para identificar o seu histórico de revisões. Então, não é possível mover ou renomear um arquivo sem interromper ou renomear seu histórico,o que, consequentemente, faz com que o histórica seja impreciso. A maioria dos controles de revisão pós-CVS resolve este problema por dar um tipo de identidade por nome único invariável para cada arquivo (um tipo de nó-i) que continua mesmo após renomeações. O Git não salva este tipo de identificador, e isso é uma vantagem alegada por Torvalds.[32][33] Arquivos de código fonte, às vezes, são divididos, mesclados ou simplesmente renomeados.[34] Salvar todas estas mudanças como simples renomes poderia congelar uma descrição imprecisa do que aconteceu na história real do mesmo (que é imutável). Git resolve este problema por detectar renomes enquanto navega pela história dos estados invés de gravá-los quando o estado é criado.[35] (Para ser breve, dado um arquivo numa revisão N, um arquivo de mesmo nome numa revisão N-1 é seu ancestral comum. Porém, quando não existe arquivo com um nome parecido na revisão N-1, o Git procura por um arquivo que existiu apenas na revisão N-1 e que era similar ao arquivo novo). No entanto, não é necessário mais tempo de processamento intensivo toda vez que o histórico é revisado. Existem também numerosas opções para ajustar estas heurísticas.\r\n"
            + "O Git implementa várias estratégias de merge (mescla de arquivos); uma não padrão pode ser selecionada durante um merge:[36]\r\n" + "\r\n"
            + "resolve (resolver): o tradicional algoritmo de merge em três vias.\r\n"
            + "recursive (recursivo): Este é o padrão quando baixando ou mesclando um branch, uma variante do algoritmo de mescla em três vias. Quando há mais de um ancestral comum que pode ser usado em um merge de três vias, cria-se uma árvore de merge dos ancestrais comuns e usa-se isso como a árvore de referência para o merge em três vias. Isto têm resultado em menor número de conflitos em merges sem causar merges errados por testes realizados em merges tirados do histórico de desenvolvimento do kernel do Linux 2.6. Adicionalmente pode detectar e lidar com merges envolvendo renomeações.\"[37]\r\n"
            + "octopus (polvo): Este é o padrão quando efetuado merge em mais de duas heads.\r\n" + "Implementação\r\n"
            + "Como o BitKeeper, o Git não usa um servidor centralizado. Entretanto, os primórdios do Git não são inerentemente um sistema de gerenciamento de versão. Torvalds explica:[38]\r\n"
            + "\r\n"
            + "Você pode ver o git apenas como um sistema de arquivos por vários motivos — ele é um armazenamento endereçável de conteúdo (SCM), e tem o conceito de versionamento, mas eu realmente o modelei vindo de um problema no ponto de vista de um sistema de arquivos (ei, eu faço núcleos de sistemas operacionais), e na verdade eu não tenho absolutamente nenhum interesse em criar um sistema tradicional de SCM.\r\n"
            + "Apesar de suas intenções, o Git agora possui toda a coleção de funcionalidade de um SCM tradicional.[39]\r\n" + "\r\n"
            + "O Git possuí duas estruturas de dados: um índice mutável que provê informações sobre o diretório de trabalho e a próxima revisão a ser cometida; e um banco de dados de objetos de acréscimo imutável.\r\n"
            + "\r\n" + "O banco de dados de objetos contém quatro tipos de objetos:\r\n" + "\r\n"
            + "Um objeto blob é o conteúdo de um arquivo. Estes objetos não possuem nomes, datações ou outros metadados.\r\n"
            + "Um objeto tree (árvore) é o equivalente a um diretório. Ele contém um lista de nomes de arquivos, cada um com bits que informam o tipo e o nome do blob, da árvore, ligação simbólica ou conteúdo de diretório que pertence a este nome. Este objeto descreve o estado da árvore de diretório.\r\n"
            + "Um objeto commit (entrega) liga árvores de objetos junto com um histórico. Ele contém o nome de uma árvore de objetos (da raiz de diretórios), datação, uma mensagem de log, e os nomes de zero ou mais objetos-pai de commit.\r\n"
            + "Um objeto tag (rótulo) é um invólucro que referencia outros objetos e pode conter metadados adicionais relacionados a outro objeto. Em geral, é usado para armazenar uma assinatura digital de um objeto commit correspondente àquela release de dados que estão sendo rastreados pelo Git.\r\n"
            + "O índice serve como um ponto de conexão entre o banco de dados de objetos e a árvore de trabalho.\r\n" + "\r\n"
            + "Cada objeto é identificado por um hash SHA-1 de seu conteúdo. O Git computa o hash e usa esse valor como nome para o objeto. O objeto é colocado em um diretório que corresponde aos primeiros dois caracteres deste hash. O resto do hash é usado como um nome de arquivo para cada objeto.\r\n"
            + "\r\n"
            + "O Git armazena cada revisão do arquivo com um único objeto blob. Os relacionamentos entre os blobs podem ser encontrados por examinar à árvore de objetos commit. Objetos recém adicionados são armazenados internamente usando compressão do zlib. Isto pode consumir uma grande quantidade de espaço de disco rapidamente. Desta forma, os objetos são combinados em pacotes, que são comprimidos em delta para salvar espaço, gravando blobs como mudanças relativas a outros blobs.\r\n"
            + "\r\n" + "Servidores Git tipicamente escutam na porta TCP/IP 9418.[40]\r\n" + "\r\n" + "Portabilidade\r\n"
            + "O Git está primariamente desenvolvido para Linux, mas pode ser usado em outros sistemas operacionais baseados no Unix, incluindo o BSD, o Solaris e o Darwin. O Git é extremamente rápido em arquiteturas POSIX como o Linux.[41]\r\n"
            + "\r\n" + "O Git também roda no Microsoft Windows. Existem duas variantes:\r\n" + "\r\n"
            + "Uma adaptação nativa para Microsoft Windows, chamada msysgit (usando MSYS da MinGW). Ao passo que é relativamente mais vagaroso que a versão para o Linux,[42] ele é rápido de forma aceitável[43] e é notoriamente usado em produção, com apenas algumas dificuldade menores.[44] Em particular, alguns comandos ainda não estão disponíveis nas GUIs, e precisam ser chamadas por linha de comando.\r\n"
            + "O git também roda em cima do Cygwin (uma camada de emulação POSIX),[45] embora é notoriamente mais lento, especialmente para comando escritos em shell script.[46] Isto é causado principalmente pelo alto custo realizado pelo comando fork emulado pelo Cygwin. Entretanto, as recentes reescritas de vários comandos do Git (originalmente escritas em shell script) para a linguagem C, resultaram em um ganho significativo de performance no Windows.[47]\r\n"
            + "Outras alternativas para rodar o Git inclui:\r\n" + "\r\n" + "git-cvsserver (que emula um servidor CVS, permitindo seu uso em cliente CVS para Windows):[48]\r\n"
            + "Ambientes de desenvolvimento baseados em Eclipse para Git, baseado em implementações puras em Java no interior do Git: egit\r\n"
            + "Suporte do NetBeans para o Git está em desenvolvimento [11] e está também disponível pelo plugin NbGit\r\n"
            + "O TortoiseGit, Git-Cheetah e o Git Extensions são extensões clientes para o Gerenciador de Arquivos do Windows, assim como versões independentes de GUI e o plugin para Visual Studio. O Git Source Control Provider é outro software gratuito em forma de plugin para o Visual Studio que exibe o status do projeto Git no 'solution explorer'.\r\n"
            + "IntelliJ IDEA Versão 8.1 agora suporta o Git por um plugin embutido: Intellij Version Control Systems Integration\r\n"
            + "Xcode 4 - assim como a versão 4 de demonstração, o git está disponível como parte da IDE [12]\r\n" + "Git#é uma implementação .Net/Mono do git.\r\n"
            + "Refatorar as operações de mais baixo nível em bibliotecas poderia, teoricamente, permitir a reimplementação do componente de níveis mais altos para o Windows sem reescrever o resto.[49]\r\n"
            + "\r\n" + "Adoção\r\n" + "Hospedagem de código fonte\r\n" + "Os seguintes websites provêm hospedagem gratuita de código fonte para repositório Git:[50]\r\n" + "\r\n"
            + "BerliOS\r\n" + "GitHub\r\n" + "Gitorious\r\n" + "Sourceforge\r\n" + "GNU Savannah\r\n" + "Project Kenai\r\n" + "Unfuddle\r\n" + "SourceRepo\r\n" + "Google Code\r\n"
            + "Bitbucket\r\n" + "GitLab\r\n" + "Azure DevOps\r\n" + "Projetos que usam Git\r\n"
            + "Um grande número de projetos de software de alto-padrão estão utilizando agora o Git como controle de revisão::[51]\r\n" + "\r\n" + "Amarok[52][53]\r\n"
            + "Android[54]\r\n" + "Arch Linux\r\n" + "Aquamacs Emacs\r\n" + "BlueZ[55]\r\n" + "Btrfs[56]\r\n" + "Clojure[57]\r\n" + "CakePHP[58]\r\n" + "cURL[59]\r\n"
            + "Debian[60]\r\n" + "Digg[61]\r\n" + "DragonFly BSD[62]\r\n" + "Eclipse[63]\r\n" + "Elinks[64]\r\n" + "Fedora\r\n" + "FFmpeg [65]\r\n" + "Freenet[66]\r\n"
            + "FreeSWITCH[67]\r\n" + "git[68]\r\n" + "GITORA\r\n" + "GIMP[69]\r\n" + "GNOME[70][71]\r\n" + "GPM[72]\r\n" + "GStreamer[73]\r\n" + "gThumb[74]\r\n" + "GTK+[75]\r\n"
            + "Hurd[76]\r\n" + "jQuery[77]\r\n" + "Laika (EHR testing framework)[78]\r\n" + "LilyPond (music typesetting)[79]\r\n" + "Linux kernel\r\n" + "Linux Mint[80][81]\r\n"
            + "LMMS[82]\r\n" + "Maemo[83]\r\n" + "MeeGo[84]\r\n" + "Merb[85]\r\n" + "MicroEMACS\r\n" + "Mono[86][87]\r\n" + "MooTools[88]\r\n"
            + "One Laptop Per Child (OLPC)[89]\r\n" + "OpenFOAM[90]\r\n" + "openSUSE[91]\r\n" + "Penumbra: Overture [92][93]\r\n" + "Perl[94]\r\n" + "PHP[95]\r\n" + "phpBB[96]\r\n"
            + "Prototype.js[97]\r\n" + "Qt[98]\r\n" + "Reddit[99]\r\n" + "rsync[100]\r\n" + "RTEMS - Real-Time Executive for Multiprocessor Systems[101]\r\n"
            + "Ruby on Rails[102]\r\n" + "Samba[103]\r\n" + "SproutCore[104]\r\n" + "Starlink[105]\r\n" + "Sugar[106]\r\n" + "SWI-Prolog[107]\r\n" + "Trilinos\r\n" + "VLC[108]\r\n"
            + "VTK[109]\r\n" + "Wine[110]\r\n" + "Xfce[111]\r\n" + "Xiph[112]\r\n" + "X.org Server[113]\r\n" + "x264[108]\r\n" + "Yahoo! UI Library[114]\r\n"
            + "Zend Framework[115]\r\n"
            + "O projeto KDE começou a migrar para o Git, o Amarok completou sua migração[116][117] e logo também a do Phonon.[118] A comunidade do Drupal recentemente anúnciou planos para migrar o desenvolvimento para Git.[119]");
  }

  private Post createPost4() {
    return newPost("Luiz Mello", "Lero Lero",
        " Lorem ipsum tempor aliquet conubia gravida magna lorem fames vestibulum class ligula orci, habitasse a porta est nostra tortor rhoncus mi scelerisque ornare quis. dictumst ut sapien semper turpis pulvinar nostra, sed rutrum felis libero quisque nisi, dui semper lectus et volutpat. arcu imperdiet feugiat ad eros tempus auctor eget consequat fames, cras ligula rutrum massa sit sagittis dictum justo eleifend, libero dictumst sociosqu himenaeos curabitur cras sem etiam. felis lobortis laoreet conubia velit fringilla aptent tristique tortor lorem, feugiat suspendisse molestie vehicula donec enim quam pretium, ante dictum sem urna quis himenaeos nisi fames. \r\n"
            + "\r\n"
            + "  Nec aliquam aptent risus integer aliquet velit faucibus risus, ultricies porta justo aliquet cras semper odio proin id, ultricies mattis platea nulla magna mollis vel. inceptos faucibus integer hac metus volutpat enim aptent, ac mauris auctor eget taciti commodo quisque, elit quisque nec donec maecenas volutpat. morbi nunc sagittis dolor quis ante donec nam sem, at egestas netus gravida sollicitudin lacus rutrum, etiam donec sagittis urna et praesent sagittis. aenean platea mauris donec eu vulputate nisi litora ante commodo fermentum tempor, ut varius ligula iaculis blandit auctor primis ultrices condimentum odio, gravida diam quis amet non ut purus pretium habitasse netus. \r\n"
            + "\r\n"
            + "  Velit quam arcu litora pulvinar fusce sit, donec iaculis viverra mattis pharetra in, luctus tristique curabitur nibh laoreet. a porta sem quis fringilla dui convallis fringilla viverra habitasse nullam libero fermentum, tincidunt vel elementum vivamus suscipit vivamus justo viverra euismod sodales ut. metus mollis commodo class ut erat sed cubilia lacus pharetra, vivamus donec curabitur auctor ipsum eros leo vestibulum vitae, tempor sapien est lectus sapien erat porta rhoncus. pretium varius orci senectus nullam hac himenaeos, adipiscing netus aliquam netus dictum ac phasellus, ultricies imperdiet fringilla condimentum auctor. nisi adipiscing aenean imperdiet pretium velit leo aenean lacinia class himenaeos sapien, aliquam neque congue suspendisse aliquam sapien odio commodo aptent. \r\n"
            + "\r\n"
            + "  Eros leo convallis lorem senectus per sapien himenaeos nisi vivamus at maecenas rutrum, leo platea massa accumsan ultricies ultrices tellus imperdiet ut commodo luctus. etiam lobortis vestibulum proin curabitur iaculis pellentesque conubia ullamcorper tristique ullamcorper mollis faucibus, viverra justo faucibus aliquam massa porttitor lacinia pellentesque erat eros class cubilia, mattis senectus vehicula semper aenean hac nullam potenti velit mollis sodales. viverra ultricies torquent aliquet placerat torquent nec sagittis viverra convallis, curae eget a justo varius curae turpis curabitur, dolor tellus molestie blandit turpis suspendisse blandit turpis. mollis semper himenaeos class nisi sagittis adipiscing integer interdum, curabitur aliquam quam pulvinar lectus netus bibendum, sit convallis faucibus tempus suscipit lectus libero. \r\n"
            + "\r\n"
            + "  Mattis torquent nec fermentum vitae ante iaculis id, leo platea ornare erat integer hac phasellus posuere, neque lobortis nec consequat quam magna. quisque varius sapien porta volutpat rhoncus consequat curabitur ullamcorper vehicula vivamus massa condimentum, suscipit quisque accumsan quisque diam orci dictum quisque vulputate accumsan egestas. sagittis duis lobortis habitasse in quis luctus rutrum, vitae interdum nisl praesent platea euismod rutrum, nibh in lacus molestie metus taciti. venenatis ad odio libero aliquam leo turpis netus, lacus sociosqu proin orci purus non vitae accumsan, porta quis sit vivamus rhoncus habitant. mauris mi nec duis habitant pellentesque posuere eu dui primis ligula curae, morbi maecenas elit lobortis viverra justo a purus aliquam a metus, donec ornare netus vulputate ullamcorper elementum nullam tincidunt facilisis erat. \r\n"
            + "\r\n"
            + "  Tincidunt non accumsan nisl iaculis sapien elit sem ut, litora suspendisse quisque tortor adipiscing fusce aptent, arcu aliquet volutpat non ornare eget amet. dapibus phasellus praesent lacus donec quis non eu lacinia scelerisque fringilla auctor, vulputate non quisque dictumst quisque sagittis magna a diam. curabitur aenean ligula ante purus id hendrerit nunc lobortis risus nunc, ultricies aptent maecenas sociosqu etiam non nostra congue enim elit sed, neque luctus blandit vestibulum ante auctor dictum ligula curabitur. porta id lobortis urna neque fames lacus commodo aliquam porttitor at consectetur, potenti ac lectus posuere eget luctus est magna pretium nulla, consequat eget etiam lacinia neque cursus nullam luctus est aenean. \r\n"
            + "\r\n"
            + "  Iaculis habitasse suspendisse class sociosqu nullam metus morbi netus conubia, orci tortor elit eu mi torquent laoreet ante ipsum, sit congue accumsan vulputate egestas vulputate hac viverra. tortor eros placerat hendrerit elementum consequat proin mauris non fringilla vehicula iaculis feugiat, egestas maecenas non habitasse nec rhoncus sed sodales torquent duis. sed condimentum suscipit commodo conubia ipsum tempus fringilla elit nisl, tempus ipsum ad posuere molestie ut convallis sollicitudin mi litora, ut ullamcorper tortor venenatis nam id ullamcorper praesent. curae consectetur eu luctus sed integer quisque phasellus hendrerit netus senectus blandit nibh consequat consectetur, rhoncus malesuada ornare tristique nibh potenti neque netus per risus sociosqu nostra. \r\n"
            + "\r\n"
            + "  Tempor ipsum vestibulum aptent habitasse ligula praesent purus sapien mauris torquent orci, lorem consectetur pretium mollis sodales et vivamus semper ornare tempor. est mollis aptent luctus dapibus, lobortis eros convallis luctus consequat, vivamus tortor mi. mollis himenaeos integer euismod morbi aliquet lorem potenti odio aenean duis, litora congue nisi proin eu varius adipiscing malesuada enim orci purus, ipsum turpis suspendisse molestie pellentesque a convallis potenti dui. consequat curabitur quam dapibus ante turpis sit placerat integer, quisque ullamcorper fermentum habitant tincidunt class venenatis, ornare lorem sollicitudin mollis mi varius nibh. senectus platea cursus adipiscing justo iaculis class venenatis mattis, etiam gravida congue dolor proin fusce pretium aenean inceptos, ultricies sem volutpat quam eros id litora. \r\n"
            + "\r\n"
            + "  Dictumst habitant sagittis posuere eu habitant ipsum quam quisque laoreet nam, malesuada per ipsum habitant eget sollicitudin volutpat inceptos sociosqu, in pretium facilisis varius dapibus mi per donec rutrum. porta congue lobortis nostra dictumst massa taciti arcu lectus, accumsan per dapibus vulputate nullam himenaeos varius conubia porttitor, molestie in elementum pellentesque sollicitudin nibh dictum. elementum vulputate diam eleifend vivamus eleifend nunc nulla nec fermentum, enim integer duis porttitor donec sociosqu ante libero nec, justo at praesent quam quis aenean lacus accumsan. ut odio hac primis quis eget commodo blandit mattis aptent ultricies, sollicitudin nullam risus venenatis egestas vel nec class eget. \r\n"
            + "\r\n"
            + "  Litora primis at aliquam hac sociosqu maecenas erat vehicula, ligula tempor elementum potenti odio erat. curabitur congue sed magna nisl euismod tellus dictumst, fames ut euismod elementum pellentesque nec rutrum, auctor eleifend vehicula interdum dictum curae. ");
  }
}
